get <- function() m                            # Returns matrix (m)
setInverse <- function(inverse) i <<- inverse  # Sets i to inverse
getInverse <- function() i                     # Returns inverse (i)
list(set = set, get = get, setInv = setInverse, getInverse = getInverse)
}
## Function 2 - Compute inverse of matrix returned by makeCacheMatrix
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setInverse(inv)                   # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
m <- matrix(rnorm(16),4,4)
## m1 <- makeCacheMatrix(m)
## cacheSolve(m1)
m1 <- makeCacheMatrix(m)
## cacheSolve(m1)
cacheSolve(m1)
## Functions for caching inverse of a matrix
## Function 1 - Creates matrix (m) object which can cache it's own inverse (i)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                          # Initiate (empty) inverse
set <- function(matrix ) {        # Set the matrix (m) and ensure empty inverse (i)
m <<- matrix
i <<- NULL
}
get <- function() m                            # Returns matrix (m)
setInverse <- function(inverse) i <<- inverse  # Sets i to inverse
getInverse <- function() i                     # Returns inverse (i)
list(set = set, get = get, setInv = setInverse, getInverse = getInverse)
}
## Function 2 - Compute inverse of matrix returned by makeCacheMatrix
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("Getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setInverse(inv)                   # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## cacheSolve is a function which computes the inverse of the special "matrix"
## returned by makeCacheMatrix above. If the inverse has already been calculated
## (and the matrix has not changed), then the cachesolve should retrieve the
## inverse from the cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(inv)) {
message("getting cached result")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinv(inv)
inv
}
m <- matrix(rnorm(16),4,4)
m1 <- makeCacheMatrix(m)
cacheSolve(m1)
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("Getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setInverse(inv)                   # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
cacheSolve(m1)
m1 <- makeCacheMatrix(m)
cacheSolve(m1)
## Functions for caching inverse of a matrix
## Function 1 - Creates matrix (m) object which can cache it's own inverse (i)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                                      # Initiate (empty) inverse
set <- function(matrix ) {                     # Set the matrix (m) and ensure empty inverse (i)
m <<- matrix
i <<- NULL
}
get <- function() m                            # Returns matrix (m)
setInverse <- function(inverse) i <<- inverse  # Sets i to inverse
getInverse <- function() i                     # Returns inverse (i)
list(set = set, get = get, setInv = setInverse, getInverse = getInverse)
}
## Function 2 - Return cache, and if not, compute inverse of matrix x
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setInverse(inv)                   # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
m1 <- makeCacheMatrix(m)
cacheSolve(m1)
## Functions for caching inverse of a matrix
## Function 1 - Creates matrix (m) object which can cache it's own inverse (i)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                                      # Initiate (empty) inverse
set <- function(matrix ) {                     # Set the matrix (m) and ensure empty inverse (i)
m <<- matrix
i <<- NULL
}
get <- function() m                            # Returns matrix (m)
setInverse <- function(inverse) i <<- inverse  # Sets i to inverse
getInverse <- function() i                     # Returns inverse (i)
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
## Function 2 - Return cache, and if not, compute inverse of matrix x
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setInverse(inv)                   # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
cacheSolve(m1)
m1 <- makeCacheMatrix(m)
cacheSolve(m1)
set.seed(1)
rpois(5, 2)
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
y
plot(y)
plot(e)
plot(x)
setwd("~/Dropbox/git/datasciencecoursera/2 R Programming")
setwd("~/Dropbox/git/datasciencecoursera/2 R Programming/ProgAssignment3-data/")
outcome <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
head(outcome)
names(outcome)
outcome[, 11] <- as.numeric(outcome[, 11])
hist(outcome[, 11])
?tolower
x <- "MiXeD cAsE 123"
chartr("iXs", "why", x)
chartr("a-cX", "D-Fw", x)
tolower(x)
toupper(x)
best <- function(state, outcome) {
out_dt <- data.table::fread('outcome-of-care-measures.csv') # Read outcome data as DT
outcome <- tolower(outcome)                                 # All lower case as
chosen_state <- state                                       # rename variable state so no conflict w/ col name
# Check that state and outcome are valid
if (!chosen_state %in% unique(out_dt[["State"]])) stop('invalid state')
if (!outcome %in% c("heart attack", "heart failure", "pneumonia")) stop('invalid outcome')
# Rename columns
setnames(out_dt, tolower(sapply(colnames(out_dt), gsub, pattern = "^Hospital 30-Day Death \\(Mortality\\) Rates from ", replacement = "" ))
)
#Filter by state
out_dt <- out_dt[state == chosen_state]
# Columns indices to keep
col_indices <- grep(paste0("hospital name|state|^",outcome), colnames(out_dt))
# Filtering out unnessecary data
out_dt <- out_dt[, .SD ,.SDcols = col_indices]
# Find out what class each column is
# sapply(out_dt,class)
out_dt[, outcome] <- out_dt[,  as.numeric(get(outcome))]
# Removing Missing Values for numerical datatype (outcome column)
out_dt <- out_dt[complete.cases(out_dt),]
# Order Column to Top
out_dt <- out_dt[order(get(outcome), `hospital name`)]
return(out_dt[, "hospital name"][1])
}
source("best.R")
best("TX", "heart attack")
library(data.table)
best("TX", "heart attack")
best("TX", "heart attacksa")
best("TXA", "heart attacksa")
out_dt <- data.table::fread('outcome-of-care-measures.csv')
head(out_dt)
setnames(out_dt, tolower(sapply(colnames(out_dt), gsub, pattern = "^Hospital 30-Day Death \\(Mortality\\) Rates from ", replacement = "" )))
head(out_dt)
names(head_dt)
names(out_dt)
out_dt <- data.table::fread('outcome-of-care-measures.csv')
names(out_dt)
setnames(out_dt, tolower(sapply(colnames(out_dt), gsub, pattern = "^Hospital 30-Day Death \\(Mortality\\) Rates from ", replacement = "" )))
names(out_dt)
col_indices <- grep(paste0("hospital name|state|^",outcome), colnames(out_dt))
?grep
?paste-
o
?paste0
paste0("hospital name|state|^",outcome)
z = paste0("hospital name|state|^",outcome)
head(z)
rm(z)
col_indices <- grep(paste0("hospital name|state|^",outcome), colnames(out_dt))
col_indices
out_dt <- data.table::fread('outcome-of-care-measures.csv')
outcome <- tolower(outcome)                                 # All lower case for future processing
chosen_state <- toupper(state)
head(out_dt)
setnames(out_dt, tolower(sapply(colnames(out_dt), gsub, pattern = "^Hospital 30-Day Death \\(Mortality\\) Rates from ", replacement = "" )))
names(out_dt)
out_dt <- out_dt[state == "TX"]
head(out_dt)
col_indices <- grep(paste0("hospital name|state|^","pneumonia"), colnames(out_dt))
col_indices
out_dt <- out_dt[, .SD ,.SDcols = col_indices]
head(out_dt)
out_dt[, outcome] <- out_dt[,  as.numeric(get(outcome))]
out_dt[, pneumonia] <- out_dt[,  as.numeric(get(pneumonia))]
out_dt[, pneumonia] <- out_dt[,  as.numeric(get(outcome))]
out_dt[, pneumonia] <- out_dt[,  as.numeric(get(pneumonia))]
out_dt <- out_dt[complete.cases(out_dt),]
out_dt[, pneumonia] <- out_dt[,  as.numeric(get(pneumonia))]
out_dt[, pneumonia] <- out_dt[,  as.numeric(pneumonia)]
?get
library(data.table)
best <- function(state, outcome) {
out_dt <- data.table::fread('outcome-of-care-measures.csv') # Read outcome data as DT
outcome <- tolower(outcome)                                 # All lower case for future processing
chosen_state <- toupper(state)                              # Rename variable state so no conflict w/ col name
# Check that state and outcome are valid and informative error if not
if (!chosen_state %in% unique(out_dt[["State"]])) stop('invalid state')
if (!outcome %in% c("heart attack", "heart failure", "pneumonia")) stop('invalid outcome')
# Rename columns by stripping mortality text... now just "heart attack", "heart failure", "pneumonia"
setnames(out_dt, tolower(sapply(colnames(out_dt), gsub, pattern = "^Hospital 30-Day Death \\(Mortality\\) Rates from ", replacement = "" )))
#Filter by state
out_dt <- out_dt[state == chosen_state]
# Find column indices relevant to that outcome (1 - hospital name, 2 - state, 3 - outcome)
col_indices <- grep(paste0("hospital name|state|^",outcome), colnames(out_dt))
# Filtering out unnessecary columns of data
out_dt <- out_dt[, .SD ,.SDcols = col_indices]
# Find out what class each column is
# sapply(out_dt,class)
out_dt[, outcome] <- out_dt[,  as.numeric(get(outcome))]
# Removing Missing Values for numerical datatype (outcome column)
out_dt <- out_dt[complete.cases(out_dt),]
# Order Column to Top
out_dt <- out_dt[order(get(outcome), `hospital name`)]
return(out_dt[, "hospital name"][1])
}
best(TX,pneumonia)
best("TX","pneumonia")
best("TX", "heart attack")
best("TX", "heart failure")
library(data.table)
best <- function(state, outcome) {
out_dt <- data.table::fread('outcome-of-care-measures.csv') # Read outcome data as DT
outcome <- tolower(outcome)                                 # All lower case for future processing
chosen_state <- toupper(state)                              # Rename variable state so no conflict w/ col name
# Check that state and outcome are valid and informative error if not
if (!chosen_state %in% unique(out_dt[["State"]])) stop('invalid state')
if (!outcome %in% c("heart attack", "heart failure", "pneumonia")) stop('invalid outcome')
# Rename columns by stripping mortality text... now just "heart attack", "heart failure", "pneumonia"
setnames(out_dt, tolower(sapply(colnames(out_dt), gsub, pattern = "^Hospital 30-Day Death \\(Mortality\\) Rates from ", replacement = "" )))
#Filter by state
out_dt <- out_dt[state == chosen_state]
# Find column indices relevant to that outcome (1 - hospital name, 2 - state, 3 - outcome)
col_indices <- grep(paste0("hospital name|state|^",outcome), colnames(out_dt))
# Filtering out unnessecary columns of data
out_dt <- out_dt[, .SD ,.SDcols = col_indices]
# Find out what class each column is
# sapply(out_dt,class)
# out_dt[, outcome] <- out_dt[,  as.numeric(get(outcome))]
# Removing Missing Values for numerical datatype (outcome column)
out_dt <- out_dt[complete.cases(out_dt),]
# Order Column to Top
out_dt <- out_dt[order(get(outcome), `hospital name`)]
return(out_dt[, "hospital name"][1])
}
best("TX", "heart failure")
best("TX", "heart attack")
best("MD", "heart attack")
best("TX", "heart failure")
library(data.table)
best <- function(state, outcome) {
out_dt <- data.table::fread('outcome-of-care-measures.csv') # Read outcome data as DT
outcome <- tolower(outcome)                                 # All lower case for future processing
chosen_state <- toupper(state)                              # Rename variable state so no conflict w/ col name
# Check that state and outcome are valid and informative error if not
if (!chosen_state %in% unique(out_dt[["State"]])) stop('invalid state')
if (!outcome %in% c("heart attack", "heart failure", "pneumonia")) stop('invalid outcome')
# Rename columns by stripping mortality text... now just "heart attack", "heart failure", "pneumonia"
setnames(out_dt, tolower(sapply(colnames(out_dt), gsub, pattern = "^Hospital 30-Day Death \\(Mortality\\) Rates from ", replacement = "" )))
#Filter by state
out_dt <- out_dt[state == chosen_state]
# Find column indices relevant to that outcome (1 - hospital name, 2 - state, 3 - outcome)
col_indices <- grep(paste0("hospital name|state|^",outcome), colnames(out_dt))
# Filtering out unnessecary columns of data
out_dt <- out_dt[, .SD ,.SDcols = col_indices]
# Find out what class each column is
# sapply(out_dt,class)
out_dt[, outcome] <- out_dt[,  as.numeric(get(outcome))]
# Removing Missing Values for numerical datatype (outcome column)
out_dt <- out_dt[complete.cases(out_dt),]
# Order Column to Top
out_dt <- out_dt[order(get(outcome), `hospital name`)]
return(out_dt[, "hospital name"][1])
}
best("TX", "heart failure")
best <- function(state, outcome){
library(dplyr)
## Read outcome data
outcomeData <- read.csv("outcome-of-care-measures.csv",colClasses = "character")
bestHospital <- NULL
rate <- NULL
## Function for heart attack
inHeartAttack <- function(s, x){
x <- select(x, State, Hospital.Name, Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack)
filtered <- x[x$State==s & x$Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack != 'Not Available' ,c("Hospital.Name","Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack")]
## Sort by Hospital name
sortedData <- arrange(filtered, Hospital.Name)
## Sort by Rate
sortedData$Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack <- as.numeric(sortedData$Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack)
sortedData <- arrange(sortedData, Hospital.30.Day.Death..Mortality..Rates.from.Heart.Attack)
## Return hospital name in that state with lowest 30-day death
bestHosp <- sortedData
}
## Function for heart failure
inHeartFailure <- function(s, x){
x <- select(x, State, Hospital.Name, Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure)
filtered <- x[x$State==s & x$Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure != 'Not Available' ,c("Hospital.Name","Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure")]
## Sort by Hospital name
sortedData <- arrange(filtered, Hospital.Name)
## Sort by Rate
sortedData$Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure <- as.numeric(sortedData$Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure)
sortedData <- arrange(sortedData, Hospital.30.Day.Death..Mortality..Rates.from.Heart.Failure)
## Return hospital name in that state with lowest 30-day death
bestHosp <- sortedData
}
## Function for pneumonia
inPneumonia <- function(s, x){
x <- select(x, State, Hospital.Name, Hospital.30.Day.Death..Mortality..Rates.from.Pneumonia)
filtered <- x[x$State==s & x$Hospital.30.Day.Death..Mortality..Rates.from.Pneumonia != 'Not Available' ,c("Hospital.Name","Hospital.30.Day.Death..Mortality..Rates.from.Pneumonia")]
## Sort by Hospital name
sortedData <- arrange(filtered, Hospital.Name)
## Sort by Rate
sortedData$Hospital.30.Day.Death..Mortality..Rates.from.Pneumonia <- as.numeric(sortedData$Hospital.30.Day.Death..Mortality..Rates.from.Pneumonia)
sortedData <- arrange(sortedData, Hospital.30.Day.Death..Mortality..Rates.from.Pneumonia)
## Return hospital name in that state with lowest 30-day death
bestHosp <- sortedData
}
## Main
## Check that outcome is valid
if (outcome == "heart attack"){
## Check that state is valid
if (length(outcomeData[outcomeData$State == state,c("State")])>0){
bh <- inHeartAttack(state, outcomeData)
bestHospital <- bh[1,c("Hospital.Name")]
rate <- bh[1,2]
} else{
print(paste("Error in best(", state, ", ", outcome,") : invalid state", sep=""))
}
} else if (outcome == "heart failure"){
## Check that state is valid
if (length(outcomeData[outcomeData$State == state,c("State")])>0){
bh <- inHeartFailure(state, outcomeData)
bestHospital <- bh[1,c("Hospital.Name")]
rate <- bh[1,2]
} else{
print(paste("Error in best(", state, ", ", outcome,") : invalid state", sep=""))
}
} else if (outcome == "pneumonia"){
## Check that state is valid
if (length(outcomeData[outcomeData$State == state,c("State")])>0){
bh <- inPneumonia(state, outcomeData)
bestHospital <- bh[1,c("Hospital.Name")]
rate <- bh[1,2]
} else{
print(paste("Error in best(", state, ", ", outcome,") : invalid state", sep=""))
}
} else{
print(paste("Error in best(", state, ", ", outcome,") : invalid outcome", sep=""))
}
bestHospital
}
best("TX", "heart failure")
best("TX", "heart attack")
possible.outcomes <- list("heart attack" = 11, "heart failure" = 17, "pneumonia" = 23)
outcome.col <- possible.outcomes[[outcome]]
outcome.col <- possible.outcomes[[pneumonia]]
outcome.col <- possible.outcomes[["pneumonia""]]
""
outcome.col <- possible.outcomes[["pneumonia"]]
outcome.col
hospital.df <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
head(hospital.df)
hospital.df[, outcome.col] <- suppressWarnings(sapply(hospital.df[, outcome.col], as.numeric))
head(hospital.df)
hospital.state.df <- subset(hospital.df, State == "TX", c(outcome.col,2))
head(hospital.state.df)
rank.list <- order(hospital.state.df[,1],hospital.state.df[,2], na.last = NA)
head(rank.list)
hospital.state.df[rank.list[num],2]
if (num == "best")
num <- 1
else if (num == "worst")
num <- length(rank.list)
else if (!is.numeric(num))
stop("Unrecognised num argument")
hospital.state.df[rank.list[1],2]
rankhospital <- function(state, outcome, num = "best") {
## Read outcome data
## Check that state and outcome are valid
## Return hospital name in that state with the given rank
## 30-day death rate
#Make list of possible values of outcome and their index
possible.outcomes <- list("heart attack" = 11, "heart failure" = 17, "pneumonia" = 23)
outcome.col <- possible.outcomes[[outcome]]
#Stop if outcome was not in possible.outcomes
if (is.null(outcome.col))
stop("invalid outcome")
#Read the csv
hospital.df <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
#Convert the desired column to numeric
hospital.df[, outcome.col] <- suppressWarnings(sapply(hospital.df[, outcome.col], as.numeric))
#Stop if state was not a possible value of states
if (!state %in% unique(hospital.df[,7]))
stop("invalid state")
#Make data.frame for state
hospital.state.df <- subset(hospital.df, State == state, c(outcome.col,2))
#Make list of positions
rank.list <- order(hospital.state.df[,1],hospital.state.df[,2], na.last = NA)
#Check validity of num argument and assign numeric value
if (num == "best")
num <- 1
else if (num == "worst")
num <- length(rank.list)
else if (!is.numeric(num))
stop("Unrecognised num argument")
hospital.state.df[rank.list[num],2]
}
rankhospital("TX", "heart failure", 4)
rankhospital("TX", "heart failure", "best")
rankhospital("MD", "heart attack", "worst")
rankall <- function(outcome, num = "best") {
## Read outcome data
## Check that state and outcome are valid
## For each state, find the hospital of the given rank
## Return a data frame with the hospital names and the
## (abbreviated) state name
#Make list of possible values of outcome and their index
possible.outcomes <- list("heart attack" = 11, "heart failure" = 17, "pneumonia" = 23)
outcome.col <- possible.outcomes[[outcome]]
#Stop if outcome was not in possible.outcomes
if (is.null(outcome.col))
stop("invalid outcome")
#Read the csv
hospital.df <- read.csv("outcome-of-care-measures.csv", colClasses = "character")
#Convert the desired column to numeric
hospital.df[, outcome.col] <- suppressWarnings(sapply(hospital.df[, outcome.col], as.numeric))
#Make data.frame for all states
hospital.states.df <- subset(hospital.df, select = c(outcome.col, 2, 7))
hospital.split.df <- split(hospital.states.df, hospital.states.df[3])
staterank <- function(hospital.state.df) {
#Make list of positions
rank.list <- order(hospital.state.df[,1],hospital.state.df[,2], na.last = NA)
#Check validity of num argument and assign numeric value
if (num == "best")
num <- 1
else if (num == "worst")
num <- length(rank.list)
else if (!is.numeric(num))
stop("Unrecognised num argument")
hospital.state.df[rank.list[num],2]
}
ranked.states <- data.frame(sapply(hospital.split.df, staterank))
ranked.states <- data.frame(ranked.states, row.names(ranked.states))
names(ranked.states) <- c("hospital", "state")
ranked.states
}
head(rankall("heart attack", 20), 10)
tail(rankall("pneumonia", "worst"), 3)
best("SC", "heart attack")
best("NY", "pneumonia")
best("AK", "pneumonia")
rankhospital("NC", "heart attack", "worst")
rankhospital("WA", "heart attack", 7)
rankhospital("TX", "pneumonia", 10)
rankhospital("NY", "heart attack", 7)
r <- rankall("heart attack", 4)
as.character(subset(r, state == "HI")$hospital)
r <- rankall("pneumonia", "worst")
as.character(subset(r, state == "NJ")$hospital)
r <- rankall("heart failure", 10)
as.character(subset(r, state == "NV")$hospital)
