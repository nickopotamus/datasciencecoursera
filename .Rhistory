complete <- function(directory, id= 1:332){
ids = c()   # Empty IDs vector
nobss = c() # Empty number of complete cases vector
filenames = list.files(directory) # Get files
for(i in id){
filepath=paste(directory,"/" ,filenames[i], sep="") # File name
data = read.csv(filepath, header = TRUE)            # Read the file
completeCases = data[complete.cases(data), ]        # Subset with no NAs
ids =  c(ids, i)                                    # Add i to vector of IDs
nobss = c(nobss, nrow(completeCases))               # Add num of completed rows from the subset to vector
}
data.frame(id=ids, nobs=nobss) # Made and return data frame of IDs against NOBS
}
complete("~Downloads/specdata", 1)
complete("~/Downloads/specdata", 1)
complete("~/Downloads/specdata", c(2, 4, 8, 10, 12))
setwd("~/Documents/git/datasciencecoursera/datasciencecoursera")
source("complete.R")
corr <- function(directory, threshold = 0){
completes = complete(directory, 1:332) # Run completes on all
completes_above_threshold = subset(completes, nobs > threshold ) # Find those above threshold
correlations <- vector() # Empty vector
filenames = list.files(directory) # List of filenames
for(i in completes_above_threshold$id){
filepath=paste(directory,"/" ,filenames[i], sep="")
data = read.csv(filepath, header = TRUE)
completeCases = data[complete.cases(data),]
count = nrow(completeCases) ## Calculate and store the number of completed cases
if( count >= threshold ) { ## Calculate and store the count of complete cases if threshold
correlations = c(correlations, cor(completeCases$nitrate, completeCases$sulfate) )
}
}
correlations # Return result
}
cr <- corr("~/Downloads/specdata", 150)
head(cr)
summary(cr)
pollutantmean("~/Downloads/specdata", "sulfate", 1:10)
pollutantmean("~/Downloads/specdata", "nitrate", 70:72)
pollutantmean("~/Downloads/specdata", "sulfate", 34)
pollutantmean("~/Downloads/specdata", "nitrate")
cc <- complete("~/Downloads/specdata", c(6, 10, 20, 34, 100, 200, 310))
print(cc$nobs)
cc
cc <- complete("~/Downloads/specdata", 54)
print(cc$nobs)
set.seed(42)
cc <- complete("~/Downloads/specdata", 332:1)
use <- sample(332, 10)
print(cc[use, "nobs"])
cr <- corr("~/Downloads/specdata")
cr <- sort(cr)
set.seed(868)
out <- round(cr[sample(length(cr), 5)], 4)
print(out)
cr <- corr("~/Downloads/specdata", 2000)
n <- length(cr)
cr <- corr("~/Downloads/specdata", 1000)
cr <- sort(cr)
print(c(n, round(cr, 4)))
cr <- corr("~/Downloads/specdata", 129)
cr <- sort(cr)
n <- length(cr)
set.seed(197)
out <- c(n, round(cr[sample(n, 5)], 4))
print(out)
swirl()
head(flags)
dim(flags)
class(flags)
as.list(flags)
cls_list <- lapply(flags, class)
cls_list
class(cls_list)
as.character(cls_list)
cls_vect <- sapply(flags, class)
class(cls_vect)
sum(flags$orange)
flag_colors <- flags[,11:17]
head(flag_colors)
lapply(flag_colors, sum)
sapply(flag_colors, sum)
sapply(flag_colors, mean)
flag_shapes <- flags[, 19:23]
lapply(flag_shapes, range)
shape_mat = sapply(flag_shapes, range)
shape_mat <- sapply(flag_shapes, range)
shape_mat
class(shape_mat)
unique(c(3, 4, 5, 5, 5, 6, 6))
unique_vals <- lapply(flags, unique)
unique_vals
sapply(unique_vals, length)
sapply(flags, unique)
lapply(unique_vals, function(elem) elem[2])
sapply(flags, unique)
vapply(flags, unique, numeric(1))
ok()
sapply(flags, class)
vapply(flags, class, character(1))
?tapply
table(flags$landmass)
table(flags$animate)
tapply(flags$animate, flags$landmass, mean)
tapply(flags$population, flags$red,
| summary)
tapply(flags$population, flags$red, summary)
tapply(flags$population, flags$landmass, summary)
?runif
swirl()
ls()
0
exit
quit()
library(datasets)
data(iris)
?iris
library(data.table)
iris_dt <- as.data.table(iris)
install.packages("data.table")
install.packages("data.table")
library(data.table)
iris_dt <- as.data.table(iris)
iris_dt[Species == "virginica"]
iris_dt[Species == "virginica",round(mean(Sepal.Length)) ]
apply(iris[, 1:4], 2, mean)
iris[Species == "virginica",round(mean(Sepal.Length)) ]
str(iris)
str(iris_dy)
str(iris_dt)
apply(iris_dt[, 1:4], 2, mean)
head(iris_dt)
?round
library(datasets)
data(mtcars)
sapply(mtcars, cyl, mean)
mtcars_dt = as.data.table(mtcars)
sapply(mtcars_dt, cyl, mean)
head(mtcars_dt)
?sapply
with(mtcars, tapply(mpg, cyl, mean))
?with
sapply(mtcars$cyl, mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
sapply(mtcars$mpg, mtcars$cyl, mean)
sapply( split(mtcars$mpg, mtcars$cyl) , mean)
split(mtcars$mpg, mtcars$cyl)
?split
head(mtcars_dt)
mtcars_dt <- mtcars_dt[,  .(mean_cols = mean(hp)), by = cyl]
head(mtcars_dt)
round(abs(mtcars_dt[cyl == 4, mean_cols] - mtcars_dt[cyl == 8, mean_cols]))
mtcars_dt[cyl == 4, mean_cols]
## Functions for caching inverse of a matrix
## Function 1 - Creates matrix (m) object which can cache it's own inverse (i)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                          # Initiate (empty) inverse
# Matrix actions
set <- function( matrix ) {        # Set the matrix (m) and ensure empty inverse (i)
m <<- matrix
i <<- NULL
}
get <- function() {                # Get returns matrix (m)
m
}
# Inverse actions
setInverse <- function(inverse) {  # Set i to inverse
i <<- inverse
}
getInverse <- function() {         # Get returns inverse (i)
i
}
#  # Return available methods
#  list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
## Function 2 - Compute inverse of matrix returned by makeCacheMatrix
cacheSolve <- function(x, ...) {
m <- x$getInverse()          # Look for cached i and assign to the matrix (m) to return
if(!is.null(m) ) {return(m)} # Return cached if available
data <- x$get()              # Get the matrix and assign to data
m <- solve(data) %*% data    # Calculate the inverse of data and assign to m to be returned
x$setInverse(m)              # Cache the inverse (returns i) on the matrix
m                            # Return the inverted matrix
}
?matrix
a = is.matrix(as.matrix(1:10))
a
a as.matrix(1:10)
a = as.matrix(1:10)
a
a = as.matrix(1:4, nrow=2, ncol=2)
a
makeCacheMatrix(a)
cacheSolve(a)
a = as.matrix(1:4)
a
a = as.matrix(1:4, nrow=2, ncol=3)
a
a = as.matrix(1:4, nrow=2, ncol=2)
c=rbind(c(1, -1/4), c(-1/4, 1))
makeCacheMatrix(c)
cacheSolve(c)
## Functions for caching inverse of a matrix
## Function 1 - Creates matrix (m) object which can cache it's own inverse (i)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                          # Initiate (empty) inverse
# Matrix actions
set <- function( matrix ) {        # Set the matrix (m) and ensure empty inverse (i)
m <<- matrix
i <<- NULL
}
get <- function() {                # Get returns matrix (m)
m
}
# Inverse actions
setInverse <- function(inverse) {  # Set i to inverse
i <<- inverse
}
getInverse <- function() {         # Get returns inverse (i)
i
}
# Return available methods
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
## Function 2 - Compute inverse of matrix returned by makeCacheMatrix
cacheSolve <- function(x, ...) {
m <- x$getInverse()          # Look for cached i and assign to the matrix (m) to return
if(!is.null(m) ) {return(m)} # Return cached if available
data <- x$get()              # Get the matrix and assign to data
m <- solve(data) %*% data    # Calculate the inverse of data and assign to m to be returned
x$setInverse(m)              # Cache the inverse (returns i) on the matrix
m                            # Return the inverted matrix
}
makeCacheMatrix(c)
cacheSolve(c)
mat, nrow = rows, ncol = cols)=rbind(c(1, -1/4), c(-1/4, 1))
matr=rbind(c(1, -1/4), c(-1/4, 1))
matr
makeCacheMatrix(matr)
## Functions for caching inverse of a matrix
## Function 1 - Creates matrix (m) object which can cache it's own inverse (i)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                          # Initiate (empty) inverse
# Matrix actions
set <- function( matrix ) {        # Set the matrix (m) and ensure empty inverse (i)
m <<- matrix
i <<- NULL
}
get <- function() {                # Get returns matrix (m)
m
}
# Inverse actions
setInverse <- function(inverse) {  # Set i to inverse
i <<- inverse
}
getInverse <- function() {         # Get returns inverse (i)
i
}
}
## Function 2 - Compute inverse of matrix returned by makeCacheMatrix
cacheSolve <- function(x, ...) {
m <- x$getInverse()          # Look for cached i and assign to the matrix (m) to return
if(!is.null(m) ) {return(m)} # Return cached if available
data <- x$get()              # Get the matrix and assign to data
m <- solve(data) %*% data    # Calculate the inverse of data and assign to m to be returned
x$setInverse(m)              # Cache the inverse (returns i) on the matrix
m                            # Return the inverted matrix
}
makeCacheMatrix(matr)
matr
str(matr)
cacheSolve(matr)
## Functions for caching inverse of a matrix
## Function 1 - Creates matrix (m) object which can cache it's own inverse (i)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                          # Initiate (empty) inverse
set <- function( matrix ) {        # Set the matrix (m) and ensure empty inverse (i)
m <<- matrix
i <<- NULL
}
get <- function() m                            # Returns matrix (m)
setInverse <- function(inverse) i <<- inverse  # Sets i to inverse
getInverse <- function() i                     # Returns inverse (i)
list(set = set, get = get, setInv = setInverse, getInverse = getInverse)
}
## Function 2 - Compute inverse of matrix returned by makeCacheMatrix
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setinv(inv)                       # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
makeCacheMatrix(matr)
cacheSolve(matr)
m <- matrix(rnorm(16),4,4)m1 <- makeCacheMatrix(m)
## cacheSolve(m1)
m <- matrix(rnorm(16),4,4)
m1 <- makeCacheMatrix(m)
cacheSolve(m1)
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(inv)) {
message("getting cached result")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinv(inv)
inv
}
m <- matrix(rnorm(16),4,4)
m1 <- makeCacheMatrix(m)
cacheSolve(m1)
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setInverse(inv)                       # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
m <- matrix(rnorm(16),4,4)
m1 <- makeCacheMatrix(m)
cacheSolve(m1)
cacheSolve(m1)
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setInverse(inv)                   # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
cacheSolve(m1)
## Functions for caching inverse of a matrix
## Function 1 - Creates matrix (m) object which can cache it's own inverse (i)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                          # Initiate (empty) inverse
set <- function(matrix ) {        # Set the matrix (m) and ensure empty inverse (i)
m <<- matrix
i <<- NULL
}
get <- function() m                            # Returns matrix (m)
setInverse <- function(inverse) i <<- inverse  # Sets i to inverse
getInverse <- function() i                     # Returns inverse (i)
list(set = set, get = get, setInv = setInverse, getInverse = getInverse)
}
## Function 2 - Compute inverse of matrix returned by makeCacheMatrix
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setInverse(inv)                   # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
m <- matrix(rnorm(16),4,4)
## m1 <- makeCacheMatrix(m)
## cacheSolve(m1)
m1 <- makeCacheMatrix(m)
## cacheSolve(m1)
cacheSolve(m1)
## Functions for caching inverse of a matrix
## Function 1 - Creates matrix (m) object which can cache it's own inverse (i)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                          # Initiate (empty) inverse
set <- function(matrix ) {        # Set the matrix (m) and ensure empty inverse (i)
m <<- matrix
i <<- NULL
}
get <- function() m                            # Returns matrix (m)
setInverse <- function(inverse) i <<- inverse  # Sets i to inverse
getInverse <- function() i                     # Returns inverse (i)
list(set = set, get = get, setInv = setInverse, getInverse = getInverse)
}
## Function 2 - Compute inverse of matrix returned by makeCacheMatrix
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("Getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setInverse(inv)                   # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinv <- function(inverse) inv <<- inverse
getinv <- function() inv
list(set = set, get = get, setinv = setinv, getinv = getinv)
}
## cacheSolve is a function which computes the inverse of the special "matrix"
## returned by makeCacheMatrix above. If the inverse has already been calculated
## (and the matrix has not changed), then the cachesolve should retrieve the
## inverse from the cache
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getinv()
if(!is.null(inv)) {
message("getting cached result")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinv(inv)
inv
}
m <- matrix(rnorm(16),4,4)
m1 <- makeCacheMatrix(m)
cacheSolve(m1)
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("Getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setInverse(inv)                   # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
cacheSolve(m1)
m1 <- makeCacheMatrix(m)
cacheSolve(m1)
## Functions for caching inverse of a matrix
## Function 1 - Creates matrix (m) object which can cache it's own inverse (i)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                                      # Initiate (empty) inverse
set <- function(matrix ) {                     # Set the matrix (m) and ensure empty inverse (i)
m <<- matrix
i <<- NULL
}
get <- function() m                            # Returns matrix (m)
setInverse <- function(inverse) i <<- inverse  # Sets i to inverse
getInverse <- function() i                     # Returns inverse (i)
list(set = set, get = get, setInv = setInverse, getInverse = getInverse)
}
## Function 2 - Return cache, and if not, compute inverse of matrix x
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setInverse(inv)                   # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
m1 <- makeCacheMatrix(m)
cacheSolve(m1)
## Functions for caching inverse of a matrix
## Function 1 - Creates matrix (m) object which can cache it's own inverse (i)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL                                      # Initiate (empty) inverse
set <- function(matrix ) {                     # Set the matrix (m) and ensure empty inverse (i)
m <<- matrix
i <<- NULL
}
get <- function() m                            # Returns matrix (m)
setInverse <- function(inverse) i <<- inverse  # Sets i to inverse
getInverse <- function() i                     # Returns inverse (i)
list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}
## Function 2 - Return cache, and if not, compute inverse of matrix x
cacheSolve <- function(x, ...) {
inv <- x$getInverse()               # Look for cached i and assign to the matrix (inv) to return
if(!is.null(inv)) {                 # Return result cached if available
message("getting cached result")
return(inv)
}
data <- x$get()                     # Get the matrix and assign to data
inv <- solve(data, ...)             # Calculate the inverse of data and assign to inv to be returned
x$setInverse(inv)                   # Cache the inverse (returns i) on the matrix
inv                                 # Return the inverted matrix
}
cacheSolve(m1)
m1 <- makeCacheMatrix(m)
cacheSolve(m1)
